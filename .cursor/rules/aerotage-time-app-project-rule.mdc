---
description: 
globs: 
alwaysApply: true
---
# Aerotage Time Reporting App - Frontend Development Rules

## üèóÔ∏è Project Context
Electron desktop app with React/TypeScript frontend connecting to AWS serverless backend (separate repository).

**Stack**: Electron + React 18 + TypeScript + Tailwind CSS + React Context API

## üö´ Critical Prohibitions

### Dependency Management ‚ö†Ô∏è CRITICAL
- **NEVER install alpha, beta, RC, or pre-release dependencies**
- **ALWAYS run `npm run check-deps` before dependency changes**
- **ALWAYS use stable versions with caret ranges (^1.2.3)**
- **NEVER add AWS CDK or infrastructure code to this repository**

### Code Standards
- **NEVER use deprecated React patterns (class components)**
- **NEVER ignore TypeScript errors or use 'any' type**
- **NEVER store sensitive data in localStorage**
- **NEVER create .js files - TypeScript only**
  - ‚ö†Ô∏è **EXCEPTION**: Critical Electron infrastructure files are allowed to remain as JavaScript:
    - `src/main/main.js` (Electron main process entry point)
    - `src/preload/preload.js` (Electron preload security bridge)
  - **Reason**: These files are core Electron infrastructure that require careful migration planning
  - **Future**: Plan dedicated TypeScript conversion as separate enhancement project

## ‚úÖ Required Patterns

### React Context State Management
```typescript
// ALWAYS use useAppContext() hook
const { state, dispatch } = useAppContext();

// ALWAYS dispatch typed actions
dispatch({ type: 'ADD_TIME_ENTRY', payload: timeEntry });

// NEVER mutate state directly
```

### Component Structure
```typescript
// ALWAYS define props interface
interface ComponentProps {
  title: string;
  onSave: (data: FormData) => void;
}

// ALWAYS use functional components
export const Component: React.FC<ComponentProps> = ({ title, onSave }) => {
  // Component logic
};
```

### API Integration
```typescript
// ALWAYS use centralized API client
import { apiClient } from '@/services/api-client';

// ALWAYS handle errors properly
try {
  const result = await apiClient.createTimeEntry(data);
  dispatch({ type: 'ADD_TIME_ENTRY', payload: result });
} catch (error) {
  console.error('API Error:', error);
  // Handle error appropriately
}
```

## üìÅ File Structure Rules

### Application Code Structure
```
src/renderer/
‚îú‚îÄ‚îÄ components/          # Reusable UI components
‚îú‚îÄ‚îÄ pages/              # Main application pages  
‚îú‚îÄ‚îÄ context/            # React Context (AppContext.tsx)
‚îú‚îÄ‚îÄ services/           # API client services
‚îú‚îÄ‚îÄ config/             # AWS and API configuration
‚îú‚îÄ‚îÄ utils/              # Utility functions
‚îî‚îÄ‚îÄ types/              # TypeScript definitions
```

### Documentation Organization ‚ö†Ô∏è CRITICAL
- **NEVER create .md files in root directory** (except README.md)
- **ALWAYS place documentation in `/docs` folder**
- **ALWAYS use organized subdirectories for logical grouping**

```
docs/
‚îú‚îÄ‚îÄ README.md                    # Documentation index
‚îú‚îÄ‚îÄ [FEATURE_NAME].md           # Core feature documentation
‚îú‚îÄ‚îÄ api-integration/            # API specs and backend coordination
‚îú‚îÄ‚îÄ implementation-guides/      # Step-by-step development guides
‚îú‚îÄ‚îÄ troubleshooting/           # Debugging and issue resolution
‚îî‚îÄ‚îÄ archive/                   # Completed work and resolved issues
```

#### Documentation Placement Rules
- **Core Features**: Place in `/docs` root (e.g., `THEME_SYSTEM_DOCUMENTATION.md`)
- **API Integration**: Place in `/docs/api-integration/`
- **Implementation Guides**: Place in `/docs/implementation-guides/`
- **Debugging/Issues**: Place in `/docs/troubleshooting/`
- **Completed Work**: Move to `/docs/archive/` when resolved
- **Project Plans**: Place in `/docs` root for visibility

## üéØ Development Guidelines

### Code Quality
- Use strict TypeScript with proper type definitions
- Follow functional programming patterns
- Use Tailwind CSS classes, avoid inline styles
- Implement proper error boundaries
- Include accessibility (ARIA labels, semantic HTML)

### Documentation Standards
- Create comprehensive documentation for all new features
- Update `/docs/README.md` index when adding new documentation
- Use clear, descriptive filenames with consistent naming conventions
- Include code examples and implementation details
- Document API integrations and backend coordination requirements

### State Management
- Use React Context with useReducer for global state
- Keep local state minimal (useState for component-specific only)
- Always wrap components needing global state with AppProvider
- Use typed actions for all state updates

### API & Backend Integration
- Backend API documentation: https://djfreip4iwrq0.cloudfront.net/
- Current API base URL: `https://k60bobrd9h.execute-api.us-east-1.amazonaws.com/dev/`
- Use AWS Amplify for authentication
- Always validate API responses
- Implement proper loading states

### Performance
- Use React.memo for expensive components
- Implement lazy loading for routes
- Optimize Context usage to prevent unnecessary re-renders
- Clean up event listeners and timers

## üß™ Testing Requirements
- Write tests for all utility functions
- Test component rendering and Context interactions
- Mock Context provider in tests
- Use Jest and React Testing Library
- Achieve minimum 80% code coverage

## üìã Current Phase: Project Management (Phase 3)
Focus on client/project CRUD operations and team management features.

## üîó Repository Architecture
- **Frontend** (this repo): Electron app with React/TypeScript
- **Backend** (separate repo): AWS serverless infrastructure
- **Coordination**: Update AWS config when backend endpoints change

## üö´ Acceptable Exceptions

### Electron Infrastructure Files
```javascript
// ‚úÖ ALLOWED: Critical Electron files (main.js, preload.js)
// These are core infrastructure requiring careful migration planning
const { app, BrowserWindow } = require('electron');  // main.js
const { contextBridge, ipcRenderer } = require('electron');  // preload.js
```

### Error Boundary Components
```typescript
// ‚ö†Ô∏è TEMPORARY: Error boundaries require class components until React 18+ alternatives
class ErrorBoundary extends Component<Props, State> {
  // Error boundary logic - plan migration to react-error-boundary library
}
```

## Examples

### ‚úÖ Correct Context Usage
```typescript
const { state, dispatch } = useAppContext();
const { timeEntries, projects, timer } = state;

const handleStartTimer = (projectId: string, description: string) => {
  dispatch({ 
    type: 'START_TIMER', 
    payload: { projectId, description } 
  });
};
```

### ‚ùå Incorrect Patterns
```typescript
// DON'T: Direct state mutation
state.timeEntries.push(newEntry);

// DON'T: Using any type
const data: any = response.data;

// DON'T: Inline styles
<div style={{ color: 'red' }}>Error</div>

// DON'T: Class components (except Error Boundaries)
class MyComponent extends React.Component {}

// DON'T: JavaScript files in application code
// ‚ùå src/renderer/components/MyComponent.js
// ‚úÖ src/renderer/components/MyComponent.tsx

// DON'T: Documentation in root directory
// ‚ùå NEW_FEATURE_GUIDE.md (in root)
// ‚úÖ docs/implementation-guides/NEW_FEATURE_GUIDE.md

// DON'T: Unorganized documentation
// ‚ùå docs/random_notes.md
// ‚úÖ docs/troubleshooting/specific_issue_resolution.md
```

### ‚úÖ Correct Documentation Organization
```bash
# New feature documentation
docs/FEATURE_NAME_REQUIREMENTS.md

# Implementation guide
docs/implementation-guides/FEATURE_NAME_IMPLEMENTATION_GUIDE.md

# API integration
docs/api-integration/FEATURE_NAME_API_SPECIFICATION.md

# Troubleshooting
docs/troubleshooting/FEATURE_NAME_DEBUGGING.md

# When feature is complete, move implementation details to archive
docs/archive/FEATURE_NAME_IMPLEMENTATION_COMPLETED.md
```

Remember: This is a professional business application requiring production-quality code with reliability, security, and user-friendliness as top priorities.

